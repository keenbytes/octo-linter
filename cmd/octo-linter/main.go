// Package main contains octo-linter command.
package main

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strconv"

	"github.com/keenbytes/broccli/v3"
	"github.com/keenbytes/octo-linter/v2/internal/linter"
	"github.com/keenbytes/octo-linter/v2/pkg/dotgithub"
	"github.com/keenbytes/octo-linter/v2/pkg/loglevel"
)

//go:generate go run ../../gen.go ../../

const configFileName = "dotgithub.yml"

// exit codes.
const (
	ExitOK                       = 0
	ExitLintErrors               = 1
	ExitLintOnlyWarnings         = 2
	ExitErrLinting               = 10
	ExitErrReadingDotGithubDir   = 20
	ExitErrGettingCfgFile        = 30
	ExitErrReadingCfgFile        = 31
	ExitErrReadingDefaultCfgFile = 32
	ExitErrReadingVarsFile       = 41
	ExitErrReadingSecretsFile    = 42
	ExitErrCheckingDstPath       = 50
	ExitDstFileIsDir             = 51
	ExitErrWritingCfg            = 52
)

const (
	// FileModeDefaultConfig sets the mode for the config file generated by the 'init' command.
	FileModeDefaultConfig = 0o600
)

var (
	errCfgFileGet               = errors.New("error getting cfg file")
	errCfgFilePopulate          = errors.New("error populating config from file")
	errCfgFileRead              = errors.New("error reading cfg file")
	errDefaultCfgFileRead       = errors.New("error reading default cfg file")
	errDotGithubDirRead         = errors.New("error reading .github directory")
	errDotGithubVarsFileRead    = errors.New("error reading vars file")
	errDotGithubSecretsFileRead = errors.New("error reading secrets file")
)

func errGettingCfgFile(err error) error {
	return fmt.Errorf("%w: %s", errCfgFileGet, err.Error())
}

func errPopulatingCfgFile(err error) error {
	return fmt.Errorf("%w: %s", errCfgFilePopulate, err.Error())
}

func errReadingCfgFile(err error) error {
	return fmt.Errorf("%w: %s", errCfgFileRead, err.Error())
}

func errReadingDefaultCfgFile(err error) error {
	return fmt.Errorf("%w: %s", errDefaultCfgFileRead, err.Error())
}

func errReadingDotGithubDir(err error) error {
	return fmt.Errorf("%w: %s", errDotGithubDirRead, err.Error())
}

func errReadingDotGithubVarsFile(err error) error {
	return fmt.Errorf("%w: %s", errDotGithubVarsFileRead, err.Error())
}

func errReadingDotGithubSecretsFile(err error) error {
	return fmt.Errorf("%w: %s", errDotGithubSecretsFileRead, err.Error())
}

func main() {
	cli := broccli.NewBroccli(
		"octo-linter",
		"Validates GitHub Actions workflow and action YAML files",
		"m@gasior.dev",
	)

	createLintCommand(cli)
	createInitCommand(cli)

	_ = cli.Command("version", "Prints version", versionHandler)

	if len(os.Args) == 2 && (os.Args[1] == "-v" || os.Args[1] == "--version") {
		os.Args = []string{"App", "version"}
	}

	os.Exit(cli.Run(context.Background()))
}

func createLintCommand(cli *broccli.Broccli) {
	cmdLint := cli.Command(
		"lint",
		"Runs the linter on files from a specific directory",
		lintHandler,
	)
	cmdLint.Flag(
		"path",
		"p",
		"DIR",
		"Path to .github directory",
		broccli.TypePathFile,
		broccli.IsDirectory|broccli.IsExistent|broccli.IsRequired,
	)
	cmdLint.Flag(
		"config",
		"c",
		"FILE",
		"Linter config with rules in YAML format",
		broccli.TypePathFile,
		broccli.IsRegularFile|broccli.IsExistent,
	)
	cmdLint.Flag("loglevel", "l", "", "One of INFO,ERR,WARN,DEBUG", broccli.TypeString, 0)
	cmdLint.Flag(
		"vars-file",
		"z",
		"",
		"Check if variable names exist in this file (one per line)",
		broccli.TypePathFile,
		broccli.IsExistent,
	)
	cmdLint.Flag(
		"secrets-file",
		"s",
		"",
		"Check if secret names exist in this file (one per line)",
		broccli.TypePathFile,
		broccli.IsExistent,
	)
	cmdLint.Flag(
		"output",
		"o",
		"DIR",
		"Path to where summary markdown gets generated",
		broccli.TypePathFile,
		broccli.IsDirectory|broccli.IsExistent,
	)
	cmdLint.Flag(
		"output-errors",
		"u",
		"INT",
		"Limit numbers of errors shown in the markdown output file",
		broccli.TypeInt,
		0,
	)
}

func createInitCommand(cli *broccli.Broccli) {
	cmdInit := cli.Command("init", "Create sample dotgithub.yml config file", initHandler)
	cmdInit.Flag(
		"destination",
		"d",
		"FILE",
		"Destination filename to write to",
		broccli.TypePathFile,
		broccli.IsNotExistent,
	)
}

func versionHandler(_ context.Context, _ *broccli.Broccli) int {
	_, _ = fmt.Fprintf(os.Stdout, VERSION+"\n")

	return ExitOK
}

func initHandler(_ context.Context, cli *broccli.Broccli) int {
	path := cli.Flag("destination")
	if path == "" {
		fileInfo, err := os.Stat(configFileName)
		if err != nil && !os.IsNotExist(err) {
			slog.Error(
				"error checking if destination path exists",
				slog.String("destination", configFileName),
				slog.String("err", err.Error()),
			)

			return ExitErrCheckingDstPath
		}

		if err == nil && fileInfo.IsDir() {
			slog.Error(
				"destination file already exists and it is a directory, remove it first or use --destination flag to change"+
					" the destination",
				slog.String("destination", configFileName),
			)

			return ExitDstFileIsDir
		}

		path = configFileName
	}

	err := os.WriteFile(path, linter.GetDefaultConfig(), FileModeDefaultConfig)
	if err != nil {
		slog.Error(
			"error writing default config",
			slog.String("path", path),
			slog.String("err", err.Error()),
		)

		return ExitErrWritingCfg
	}

	slog.Info(
		"Sample configuration file has been created. Run 'lint' command with '-c' flag or put the file in the .github"+
			" directory.",
		slog.String("path", path),
	)

	return ExitOK
}

func lintHandler(ctx context.Context, cli *broccli.Broccli) int {
	setLogger(cli.Flag("loglevel"))

	lint, err := getLinter(cli.Flag("config"), cli.Flag("path"))
	if err != nil && errors.Is(err, errCfgFileGet) {
		return ExitErrGettingCfgFile
	}

	if err != nil && errors.Is(err, errCfgFileRead) {
		return ExitErrReadingCfgFile
	}

	if err != nil && errors.Is(err, errDefaultCfgFileRead) {
		return ExitErrReadingDefaultCfgFile
	}

	dotGithub, err := getDotGithub(
		ctx,
		cli.Flag("path"),
		cli.Flag("vars-file"),
		cli.Flag("secrets-file"),
	)
	if err != nil && errors.Is(err, errDotGithubDirRead) {
		return ExitErrReadingDotGithubDir
	}

	if err != nil && errors.Is(err, errDotGithubVarsFileRead) {
		return ExitErrReadingVarsFile
	}

	if err != nil && errors.Is(err, errDotGithubSecretsFileRead) {
		return ExitErrReadingSecretsFile
	}

	outputLimit := 0
	if cli.Flag("output-errors") != "" {
		// flag is already validated by the cli
		outputLimit, _ = strconv.Atoi(cli.Flag("output-errors"))
	}

	status, err := lint.Lint(dotGithub, cli.Flag("output"), outputLimit)
	if err != nil {
		slog.Error(
			"error linting",
			slog.String("err", err.Error()),
		)

		return ExitErrLinting
	}

	if status == linter.HasErrors {
		return ExitLintErrors
	}

	if status == linter.HasOnlyWarnings {
		return ExitLintOnlyWarnings
	}

	return 0
}

func getConfigFilePath(filePath string, dotGitHubPath string) (string, error) {
	if filePath != "" {
		return filePath, nil
	}

	configInDotGithub := filepath.Join(dotGitHubPath, configFileName)
	_, err := os.Stat(configInDotGithub)

	notFound := os.IsNotExist(err)
	if err != nil && !notFound {
		slog.Error(
			"error getting config file",
			slog.String("err", err.Error()),
		)

		return "", fmt.Errorf(
			"error getting os.Stat on %s inside .github path: %w",
			configFileName,
			err,
		)
	}

	if notFound {
		return "", nil
	}

	return configInDotGithub, nil
}

func populateConfigFromFile(cfg *linter.Config, cfgFile string) error {
	if cfgFile != "" {
		err := cfg.ReadFile(cfgFile)
		if err != nil {
			slog.Error(
				"error reading config file",
				slog.String("path", cfgFile),
				slog.String("err", err.Error()),
			)

			return errReadingCfgFile(err)
		}
	} else {
		err := cfg.ReadDefaultFile()
		if err != nil {
			slog.Error(
				"error reading default config file",
				slog.String("err", err.Error()),
			)

			return errReadingDefaultCfgFile(err)
		}
	}

	return nil
}

func getLinter(cfgPath string, dotGithubPath string) (*linter.Linter, error) {
	cfgFile, err := getConfigFilePath(cfgPath, dotGithubPath)
	if err != nil {
		return nil, errGettingCfgFile(err)
	}

	configInstance := linter.Config{}

	err = populateConfigFromFile(&configInstance, cfgFile)
	if err != nil {
		return nil, errPopulatingCfgFile(err)
	}

	linterInstance := &linter.Linter{
		Config: &configInstance,
	}

	return linterInstance, nil
}

func getDotGithub(
	ctx context.Context,
	dotGithubPath string,
	varsFile string,
	secretsFile string,
) (*dotgithub.DotGithub, error) {
	dotGithub := dotgithub.DotGithub{}

	err := dotGithub.ReadDir(ctx, dotGithubPath)
	if err != nil {
		slog.Error(
			"error initializing",
			slog.String("path", dotGithubPath),
			slog.String("err", err.Error()),
		)

		return nil, errReadingDotGithubDir(err)
	}

	if varsFile != "" {
		err = dotGithub.ReadVars(varsFile)
		if err != nil {
			slog.Error(
				"error reading vars file",
				slog.String("path", varsFile),
				slog.String("err", err.Error()),
			)

			return nil, errReadingDotGithubVarsFile(err)
		}
	}

	if secretsFile != "" {
		err = dotGithub.ReadSecrets(secretsFile)
		if err != nil {
			slog.Error(
				"error reading secrets file",
				slog.String("path", secretsFile),
				slog.String("err", err.Error()),
			)

			return nil, errReadingDotGithubSecretsFile(err)
		}
	}

	return &dotGithub, nil
}

func setLogger(loglevelFlag string) {
	logLevel := loglevel.GetLogLevelFromString(loglevelFlag)

	opts := &slog.HandlerOptions{
		Level: logLevel,
	}
	logger := slog.New(slog.NewTextHandler(os.Stderr, opts))
	slog.SetDefault(logger)
}
